#lang racket/base

(require racket/match
         racket/list
         "./types.rkt"
         (prefix-in ir: (submod "./ir.rkt" ir))
         racket/string)

(provide ir->luau)
(provide ir->luau luau-ast->string)

(struct luau-quasiquote (pattern) #:prefab)
(struct luau-unquote (pattern) #:prefab)

(define (ir->luau node)
  (match node
    [(ir:ir-literal value)
     (cond
       [(number? value) value]
       [(string? value) (format "~s" value)]
       [(boolean? value) (if value "true" "false")]
       [(null? value) "{}"]
       [else (format "nil -- unsupported literal: ~a" value)])]
    
    [(ir:ir-var-ref name) 
     (let ([name-str (symbol->string name)])
       ;; Map common Racket functions to their Luau equivalents
       (cond
         ;; Arithmetic operators with proper precedence handling
         [(eq? name '+) "+"]
         [(eq? name '-) "-"]
         [(eq? name '*) "*"]
         [(eq? name '/) "/"]
         [(eq? name 'expt) "^"]  ; Add exponentiation
         [(eq? name 'sqrt) "math.sqrt"]  ; Add square root
         [(eq? name 'floor) "math.floor"]
         [(eq? name 'ceiling) "math.ceil"]
         [(eq? name 'abs) "math.abs"]
         [(eq? name 'min) "math.min"]
         [(eq? name 'max) "math.max"]
         [(eq? name 'pi) "math.pi"]  ; Add pi constant
         
         ;; I/O operations
         [(eq? name 'display) "print"]
         [(eq? name 'newline) "print"] ;; print with no args adds a newline
         
         ;; List operations
         [(eq? name 'first) "table.first"]
         [(eq? name 'rest) 
          ;; In Luau, we'll need a helper function for 'rest'
          "(function(t) local result = {}; for i=2,#t do result[i-1] = t[i] end; return result; end)"]
         
         ;; Just use the name as is for other cases
         [else name-str]))]
    
    [(ir:ir-lambda formals body)
     (let* ([param-names (map symbol->string formals)]
            [params-str (string-join param-names ", ")]
            [body-exprs (map ir->luau body)]
            [body-str (string-join body-exprs "\n")])
       (format "function(~a)\n~a\nend" params-str body-str))]
    
    [(ir:ir-app func args)
     (let* ([func-luau (ir->luau func)]
            [args-strs (map (lambda (arg)
                              (let ([result (ir->luau arg)])
                                (if (string? result)
                                    result
                                    (format "~a" result))))
                          args)]
            [args-str (string-join args-strs ", ")])
       (cond
         ;; Handle arithmetic operators with proper precedence
         [(member func-luau (list "+" "-" "*" "/" "^"))
          (cond
            ;; Unary minus
            [(and (equal? func-luau "-") (= (length args) 1))
             (format "-~a" (car args-strs))]
            ;; Binary operators
            [(= (length args) 2)
             (format "(~a ~a ~a)" 
                     (car args-strs)
                     func-luau
                     (cadr args-strs))]
            ;; Handle variadic operators (+ and *)
            [(and (member func-luau (list "+" "*")) (> (length args) 2))
             (format "(%s)" 
                     (string-join args-strs (format " ~a " func-luau)))]
            ;; Error for other operators with wrong arity
            [else
             (error 'ir->luau "Invalid number of arguments for arithmetic operator ~a" func-luau)])]
         
         ;; Handle math functions
         [(member func-luau (list "math.sqrt" "math.floor" "math.ceil" "math.abs" 
                                 "math.min" "math.max"))
          (format "~a(~s)" func-luau args-str)]
         
         ;; Special case: module declaration
         [(and (ir:ir-var-ref? func) (eq? (ir:ir-var-ref-name func) 'module))
          (let* ([module-name (if (> (length args) 0) 
                               (ir->luau (first args))
                               "unnamed_module")]
                 [module-lang (if (> (length args) 1)
                               (ir->luau (second args))
                               "racket/base")]
                 [module-body (if (> (length args) 2)
                               (map (lambda (expr) 
                                     (let ([result (ir->luau expr)])
                                       (if (string? result)
                                           result
                                           (luau-ast->string result))))
                                    (drop args 2))
                               '())]
                 [module-body-str (string-join module-body "\n\n")])
            (format "-- Module: ~a\n-- Language: ~a\n\n~a" module-name module-lang module-body-str))]
         
         ;; Special case: function definition
         [(and (ir:ir-var-ref? func) (eq? (ir:ir-var-ref-name func) 'define) 
               (>= (length args) 2) (ir:ir-app? (first args)))
          (let* ([func-app (first args)]
                 [func-name (ir->luau (ir:ir-app-func func-app))]
                 [func-params (map (lambda (param)
                                    (let ([param-str (ir->luau param)])
                                      (if (string? param-str)
                                          param-str
                                          (format "~a" param-str))))
                                  (ir:ir-app-args func-app))]
                 [func-params-str (string-join func-params ", ")]
                 [func-body (ir->luau (second args))]
                 [func-body-str (if (string? func-body)
                                   func-body
                                   (format "~a" func-body))])
            (format "function ~a(~a)\n  return ~a\nend" func-name func-params-str func-body-str))]
         
         ;; Default: regular function call
         [else
          (format "~a(~a)" func-luau args-str)]))]
    
    [(ir:ir-if test then else)
     (let* ([test-str (ir->luau test)]
            [then-str (ir->luau then)]
            [else-str (ir->luau else)])
       (format "if ~a then\n~a\nelse\n~a\nend" test-str then-str else-str))]
    
    [(ir:ir-pat-list elements rest)
     (let ([elements-str (string-join 
                          (map (lambda (elem) 
                                (let ([result (ir->luau elem)])
                                  (if (string? result)
                                      result
                                      (luau-ast->string result))))
                               elements) 
                          ", "))])
       (if rest
           (let ([rest-str (let ([result (ir->luau rest)])
                             (if (string? result)
                                 result
                                 (luau-ast->string result)))])
             (format "{~a, ...~a}" elements-str rest-str))
           (format "{~a}" elements-str)))]
    
    [(ir:ir-pat-literal value)
     (cond
       [(number? value) (number->string value)]
       [(string? value) (format "~s" value)]
       [(boolean? value) (if value "true" "false")]
       [(symbol? value) (format "~s" (symbol->string value))]
       [(null? value) "{}"]
       [else (format "nil -- unsupported pattern literal: ~a" value)])]
    
    [(ir:ir-pat-var name)
     (symbol->string name)]
    
    [(ir:ir-pat-quasiquote pattern)
     (luau-quasiquote (ir->luau pattern))]
    
    [(ir:ir-pat-unquote pattern)
     (luau-unquote (ir->luau pattern))]
    
    [(ir:ir-module requires provides body)
     (let* ([body-strs (map (lambda (node)
                               (let ([result (ir->luau node)])
                                 (if (string? result)
                                     result
                                     (luau-ast->string result))))
                             body)]
            [body-str (string-join body-strs "\n")])
       body-str)]
    
    [(ir:ir-begin exprs)
     (let* ([expr-strs (map (lambda (node)
                               (let ([result (ir->luau node)])
                                 (if (string? result)
                                     result
                                     (luau-ast->string result))))
                             exprs)]
            [expr-str (string-join expr-strs "\n")])
       expr-str)]
    
    [(ir:ir-define name value)
     (let* ([name-str (symbol->string name)]
            [value-str (let ([result (ir->luau value)])
                         (if (string? result)
                             result
                             (luau-ast->string result)))])
       (format "local ~a = ~a" name-str value-str))]
    
    [(ir:ir-define-struct name fields)
     (let* ([struct-name (symbol->string name)]
            [pred-name (format "~a_p" struct-name)]
            [constructor-name struct-name]
            [field-names (map symbol->string fields)]
            [accessor-defs (string-join 
                            (map (lambda (field) 
                                   (format "function ~a_~a(obj) return obj.~a end" 
                                           struct-name field field))
                                 field-names)
                            "\n")]
            [constructor-params (string-join field-names ", ")]
            [field-inits (string-join 
                          (map (lambda (field) (format "~a = ~a" field field)) 
                               field-names)
                          ", ")])
       (format "-- Struct definition for ~a\nfunction ~a(~a)\n  return {~a}\nend\n~a\nfunction ~a(obj)\n  return type(obj) == \"table\"\nend"
               struct-name constructor-name constructor-params field-inits accessor-defs pred-name))]
    
    [(ir:ir-struct-ref instance index name)
     (let* ([instance-str (let ([result (ir->luau instance)])
                            (if (string? result)
                                result
                                (luau-ast->string result)))]
            [field-name (symbol->string name)])
       (format "~a.~a" instance-str field-name))]
    
    [(ir:ir-var-set name value)
     (let* ([name-str (symbol->string name)]
            [value-str (let ([result (ir->luau value)])
                        (if (string? result)
                            result
                            (format "~a" result)))])
       (format "~a = ~a" name-str value-str))]
    
    [(ir:ir-let bindings body)
     (let* ([binding-strs (map (lambda (binding)
                                 (let* ([var (first binding)]
                                        [val (second binding)]
                                        [var-str (symbol->string var)]
                                        [val-str (let ([result (ir->luau val)])
                                                   (if (string? result)
                                                       result
                                                       (luau-ast->string result)))])
                                   (format "local ~a = ~a" var-str val-str)))
                               bindings)]
            [binding-block (string-join binding-strs "\n")]
            [body-strs (map (lambda (expr)
                              (let ([result (ir->luau expr)])
                                (if (string? result)
                                    result
                                    (luau-ast->string result))))
                            body)]
            [body-block (string-join body-strs "\n")])
       (format "do\n~a\n~a\nend" binding-block body-block))]
    
    [(ir:ir-letrec bindings body)
     (let* ([var-decls (map (lambda (binding)
                              (let* ([var (first binding)]
                                     [var-str (symbol->string var)])
                                (format "local ~a" var-str)))
                            bindings)]
            [var-decl-block (string-join var-decls "\n")]
            [var-inits (map (lambda (binding)
                              (let* ([var (first binding)]
                                     [val (second binding)]
                                     [var-str (symbol->string var)]
                                     [val-str (let ([result (ir->luau val)])
                                                (if (string? result)
                                                    result
                                                    (luau-ast->string result)))])
                                (format "~a = ~a" var-str val-str)))
                            bindings)]
            [var-init-block (string-join var-inits "\n")]
            [body-strs (map (lambda (expr)
                              (let ([result (ir->luau expr)])
                                (if (string? result)
                                    result
                                    (luau-ast->string result))))
                            body)]
            [body-block (string-join body-strs "\n")])
       (format "do\n~a\n~a\n~a\nend" var-decl-block var-init-block body-block))]
    
    [(ir:ir-match target clauses)
     (let* ([target-str (ir->luau target)]
            [clause-strs 
             (map (lambda (clause)
                    (match clause
                      [(list pattern #f body)  ; No guard condition
                       (let* ([pattern-str (ir->luau pattern)]
                              [body-str (ir->luau body)])
                         (format "if match(~a, ~a) then\n  return ~a\n" 
                                 target-str pattern-str body-str))]
                      [(list pattern guard body)  ; With guard condition
                       (let* ([pattern-str (ir->luau pattern)]
                              [guard-str (ir->luau guard)]
                              [body-str (ir->luau body)])
                         (format "if match(~a, ~a) and ~a then\n  return ~a\n" 
                                 target-str pattern-str guard-str body-str))]
                      [_ (error 'ir->luau "Invalid match clause")]))
                  clauses)]
            [match-str (string-join clause-strs "else")])
       (format "do\n~a\nend" match-str))]
    
    [_ (format "-- Unsupported node type: ~a" (object-name node))]))

(define (luau-ast->string node)
  (cond
    [(luau-quasiquote? node)
     (format "`%s" (luau-ast->string (luau-quasiquote-pattern node)))]
    
    [(luau-unquote? node)
     (format "${%s}" (luau-ast->string (luau-unquote-pattern node)))]
    
    [(string? node) node]
    
    [else (format "~a" node)]))

(define (luau-node-type node)
  (cond
    [(luau-quasiquote? node) 'luau-quasiquote]
    [(luau-unquote? node) 'luau-unquote]
    [else (error 'luau-node-type "Unsupported node type: ~a" node)])) 