#lang racket/base

(require racket/match
         (except-in racket/string string-contains?)
         racket/list  ; For last and drop-right
         racket/hash  ; For hash operations
         racket/struct-info  ; For struct type information
         (prefix-in ir: (submod "./ir.rkt" ir))
         "./types.rkt"  ; Import all types directly
         )

;; Define structs for quasiquote and unquote nodes if they don't exist in types.rkt
(struct luau-quasiquote (pattern) #:transparent #:prefab)
(struct luau-unquote (pattern) #:transparent #:prefab)

(provide ir->luau
         luau-ast->string
         luau-quasiquote
         luau-quasiquote?
         luau-quasiquote-pattern
         luau-unquote
         luau-unquote?
         luau-unquote-pattern
         )

;; ===== HELPER FUNCTIONS =====

;; TODO: Implement gensym or unique name generation
(define temp-counter 0)
(define (gensym base)
  (set! temp-counter (+ temp-counter 1))
  (string->symbol (string-append base "_" (number->string temp-counter))))

;; Helper to add return statements to the body of a function
(define (add-returns body)
  (if (null? body)
      '()
      (let ([init-body (drop-right body 1)]
            [last-expr (last body)])
        (match last-expr
          [(luau-return _) last-expr] ; Already a return
          [_ (append init-body (list (luau-return last-expr)))]))))


;; Helper to check if a Luau AST node represents 'true'
(define (is-luau-true? node)
  (match node
    [(luau-literal v) (eq? v #true)]
    [_ #f]))

;; Helper to combine conditions with 'and' smartly
(define (luau-and c1 c2)
  (cond
    [(is-luau-true? c1) c2]
    [(is-luau-true? c2) c1]
    [else (luau-binop "and" c1 c2)]))


;; ===== PATTERN MATCHING CODEGEN =====

;; generate-pattern-check: ir-pattern luau-ast -> (luau-ast . listof[luau-ast])
;; Returns (condition . bindings)
(define (generate-pattern-check pat target-var)
  (match pat
    [(? ir:ir-pat-literal? pat) ; Match using the predicate
     (let ([val (ir:ir-pat-literal-value pat)])
       (cons (luau-binop "==" target-var (luau-literal val)) '()))]

    [(? ir:ir-pat-wildcard? pat) ; Match using the predicate
     (cons (luau-literal #true) '())]

    [(? ir:ir-pat-var? pat) ; Match using the predicate
     (let ([name (ir:ir-pat-var-name pat)])
       (cons (luau-literal #true) ; Always matches
             (list (luau-assign-local (symbol->string name) target-var))))] ; Bind variable

    [(? ir:ir-pat-list? pat) ; Match using the predicate
     (let* (
            [elements (ir:ir-pat-list-elements pat)]
            [rest-pat (ir:ir-pat-list-rest pat)]
            [num-elements (length elements)]
            [type-check (luau-binop "==" (luau-call (luau-var "typeof") (list target-var)) (luau-literal "table"))]
            [length-check (if rest-pat
                              (luau-binop ">=" (luau-call (luau-var "#") (list target-var)) (luau-literal num-elements))
                              (luau-binop "==" (luau-call (luau-var "#") (list target-var)) (luau-literal num-elements)))]
            [initial-condition (luau-and type-check length-check)]
            [result 
             (for/fold ([acc (cons initial-condition '())])
                       ([i (in-range 1 (add1 num-elements))] [elem-pat elements])
               (let* ([elem-target (luau-field-access target-var (number->string i))]
                      ;; Bind the result pair first
                      [check-result (generate-pattern-check elem-pat elem-target)]
                      [sub-cond (car check-result)]
                      [sub-bindings (cdr check-result)]
                      [new-cond (luau-and (car acc) sub-cond)]
                      [new-bindings (append (cdr acc) sub-bindings)])
                 (cons new-cond new-bindings)))]
            [final-condition (car result)]
            [final-bindings (cdr result)]
            [rest-result
             (if rest-pat
                 (let* ([rest-slice-expr (luau-call (luau-var "_apollo_slice") (list target-var (luau-literal (add1 num-elements))))]
                        [rest-temp-var-name (symbol->string (gensym "_rest_slice"))]
                        [rest-temp-var (luau-var rest-temp-var-name)]
                        [assign-rest-slice (luau-assign-local rest-temp-var-name rest-slice-expr)]
                        [check-result (generate-pattern-check rest-pat rest-temp-var)]
                        [rest-cond (car check-result)]
                        [rest-bindings (cdr check-result)]
                        [final-cond-with-rest (luau-and final-condition rest-cond)]
                        [final-bindings-with-rest (cons assign-rest-slice (append final-bindings rest-bindings))])
                   (cons final-cond-with-rest final-bindings-with-rest))
                 (cons final-condition final-bindings))])
       rest-result)]

    [(? ir:ir-pat-struct? pat) ; Match using the predicate
     (let* ([name (ir:ir-pat-struct-name pat)] ; Extract struct name as a symbol
            [struct-name (symbol->string name)] ; Convert to string for Lua
            [field-patterns (ir:ir-pat-struct-fields pat)]
            [num-fields (length field-patterns)]
            ; Base checks
            [type-check (luau-binop "==" (luau-call (luau-var "typeof") (list target-var)) (luau-literal "table"))]
            [type-field-access (luau-field-access target-var (luau-literal "__type"))]
            [type-check-expr (luau-binop "==" type-field-access (luau-literal struct-name))]
            [initial-condition (luau-and type-check type-check-expr)]
            ; Recursive checks for fields
            [result
             (for/fold ([acc (cons initial-condition '())])
                       ([i (in-range 1 (add1 num-fields))] [field-pat field-patterns])
               (let* ([field-target (luau-field-access target-var (number->string i))]
                      ;; Bind the result pair first
                      [check-result (generate-pattern-check field-pat field-target)]
                      [sub-cond (car check-result)]
                      [sub-bindings (cdr check-result)]
                      [new-cond (luau-and (car acc) sub-cond)]
                      [new-bindings (append (cdr acc) sub-bindings)])
                 (cons new-cond new-bindings)))]
            [final-condition (car result)]
            [final-bindings (cdr result)])
      (cons final-condition final-bindings))]

    ;; Quasiquote pattern
    [(? ir:ir-pat-quasiquote? pat)
     (generate-pattern-check (ir:ir-pat-quasiquote-pattern pat) target-var)]
     
    ;; Unquote pattern (inside a quasiquote)
    [(? ir:ir-pat-unquote? pat)
     (generate-pattern-check (ir:ir-pat-unquote-pattern pat) target-var)]

    [_ (error 'generate-pattern-check "Unsupported pattern type: ~s" pat)]))


;; generate-match: ir-expr listof[(ir-pattern ir-guard? ir-expr)] -> luau-ast
(define (generate-match target-expr clauses)
  (let* ([target-luau (ir->luau target-expr)]
         ; Use gensym for temporary variable names
         [target-var-name (symbol->string (gensym "_match_target"))]
         [result-var-name (symbol->string (gensym "_match_result"))]
         [target-var (luau-var target-var-name)]
         [result-var (luau-var result-var-name)])

    ;; Recursive function to build the if/elseif chain
    (define (build-match-if clauses)
      (if (null? clauses)
          ;; No match found - runtime error
          (luau-call (luau-var "error") (list (luau-literal "Match failure")))
          (let* ([current-clause (car clauses)]
                 [rest-clauses (cdr clauses)]
                 [pattern (first current-clause)]
                 [has-guard? (and (= (length current-clause) 3) (second current-clause))]
                 [guard-expr (if has-guard? (second current-clause) #f)]
                 [result-ir (if has-guard? (third current-clause) (second current-clause))]
                 ;; Bind the result pair first
                 [check-result (generate-pattern-check pattern target-var)]
                 [condition (car check-result)]
                 [bindings (cdr check-result)]
                 ;; If there's a guard condition, include it
                 [final-condition (if has-guard?
                                      (luau-and condition (ir->luau guard-expr))
                                      condition)]
                 [result-luau (ir->luau result-ir)]
                 [then-body (luau-block (append bindings
                                                 (list (luau-assign result-var result-luau))))]
                 [else-body (build-match-if rest-clauses)])
            ;; Create the if node
            (luau-if final-condition then-body else-body))))

    ;; The final Luau code is a block:
    ;; 1. Assign target expression to a local variable
    ;; 2. Declare local variable for the result
    ;; 3. The if/elseif structure that assigns to the result variable
    ;; 4. The result variable itself (as the value of the block)
    (luau-block
     (list
      (luau-assign-local target-var-name target-luau)
      (luau-assign-local result-var-name (luau-literal 'null)) ; Initialize result var
      (build-match-if clauses)
      result-var)))) ; The block's "value" is the final result


;; ===== IR TO LUAU TRANSFORMATION =====

;; Helper function for list slicing (used in pattern matching for rest patterns)
(define apollo-slice-function
  (luau-function-def 
   "_apollo_slice"
   (list (luau-var "t") (luau-var "start"))
   (list
    (luau-assign-local "result" (luau-table-literal '()))
    (luau-assign-local "len" (luau-call (luau-var "#") (list (luau-var "t"))))
    (luau-assign-local "j" (luau-literal 1))
    (luau-for-numeric 
     "i" 
     (luau-var "start") 
     (luau-var "len") 
     #f
     (luau-block 
      (list
       (luau-assign 
        (luau-field-access (luau-var "result") (luau-var "j"))
        (luau-field-access (luau-var "t") (luau-var "i")))
       (luau-assign 
        (luau-var "j") 
        (luau-binop "+" (luau-var "j") (luau-literal 1))))))
    (luau-return (luau-var "result")))))

;; Add helper functions to a module
(define (add-helpers-to-module module)
  (struct-copy luau-module module
               [body (cons apollo-slice-function (luau-module-body module))]))

;; Dispatcher for converting IR nodes to Luau AST nodes
(define (ir->luau ir-node)
  (match ir-node
    ;; Simple literals
    [(ir:ir-literal val)
     (luau-literal val)]

    ;; Variable reference
    [(ir:ir-var-ref name)
     (luau-var (symbol->string name))]

    ;; Variable assignment
    [(ir:ir-var-set name value)
     (luau-assign (luau-var (symbol->string name)) (ir->luau value))]

    ;; Variable definition
    [(ir:ir-define name value)
     (let ([value-ast (ir->luau value)])
       (if (luau-function-def? value-ast)
           ;; If it's a function definition, update its name
           (struct-copy luau-function-def value-ast
                        [name (symbol->string name)])
           ;; Otherwise, create a local variable assignment
           (luau-assign-local (symbol->string name) value-ast)))]

    ;; Quasiquote and unquote patterns
    [(ir:ir-pat-quasiquote pattern)
     (luau-quasiquote (ir->luau pattern))]
     
    [(ir:ir-pat-unquote pattern)
     (luau-unquote (ir->luau pattern))]

    ;; Lambda expression
    [(ir:ir-lambda params body)
     (if (list? body)
         ;; List of body expressions
         (luau-func
          (map (lambda (p) (luau-var (symbol->string p))) params)
          (luau-block
           (if (null? (cdr body))
               ;; Single body expression: convert to return
               (list (luau-return (ir->luau (car body))))
               ;; Multiple expressions: convert the last one to return
               (append
                (map ir->luau (take body (sub1 (length body))))
                (list (luau-return (ir->luau (last body))))))))
         ;; Single body expression
         (luau-func
          (map (lambda (p) (luau-var (symbol->string p))) params)
          (luau-block (list (luau-return (ir->luau body))))))]

    ;; Let/letrec binding (convert to nested scopes)
    [(ir:ir-let bindings body)
     (generate-let-binding bindings body)]
    [(ir:ir-letrec bindings body)
     (generate-let-binding bindings body)] ; Using the same generation for now

    ;; Begin (sequence of expressions)
    [(ir:ir-begin exprs)
     (if (null? exprs)
         ;; Empty begin
         (luau-block '())
         ;; Non-empty begin: convert the last one to return
         (let ([body-asts (map ir->luau exprs)])
           (luau-block
            (if (= (length body-asts) 1)
                ;; Convert single-expression begin to return
                (list (luau-return (car body-asts)))
                ;; Make a block with the last expression as a return
                (append
                 (take body-asts (sub1 (length body-asts)))
                 (list (luau-return (last body-asts))))))))]

    ;; If expression
    [(ir:ir-if test then else)
     (luau-if
      (ir->luau test)
      (luau-block (list (luau-return (ir->luau then))))
      (luau-block (list (luau-return (ir->luau else)))))]

    ;; Struct definition
    [(ir:ir-define-struct name fields)
     (let* ([num-fields (length fields)]
            [param-names (map symbol->string fields)]
            [constructor-body
             (luau-block
              (list
               (luau-assign-local "instance" (luau-table-kv-literal '()))
               ;; Assign fields using numeric indices
               (luau-block
                (for/list ([i (in-range 1 (add1 num-fields))] ; Luau 1-based index
                           [p-name param-names])
                  (luau-assign (luau-field-access (luau-var "instance") (number->string i))
                                 (luau-var p-name))))
               ;; Add __type field
               (luau-assign (luau-field-access (luau-var "instance") (luau-literal "__type"))
                              (luau-literal (symbol->string name)))
               (luau-return (luau-var "instance"))))])
       (luau-function-def (string-append "make-" (symbol->string name))
                         (map luau-var param-names)
                         (luau-block-stmts constructor-body)))]

    ;; Struct field access
    [(ir:ir-struct-ref instance index _name) ; _name ignored for now, use index
     (luau-field-access (ir->luau instance) (luau-literal (number->string index)))] ; Luau 1-based index

    ;; === Match Expression ===
    [(ir:ir-match target clauses)
     (generate-match target clauses)]

    ;; Application
    [(ir:ir-app func args)
     ;; TODO: Add back special handling for operators, ffi etc. if needed
     (luau-call (ir->luau func) (map ir->luau args))]

    ;; Program node
    [(ir:ir-program body)
     ; Wrap the generated block in a luau-module structure
     (add-helpers-to-module
      (luau-module '() ; Empty requires
                   (map ir->luau body) ; Process body statements
                   '())) ; Empty exports for now
     ]

    [_ (error 'ir->luau "Unsupported IR node: ~s" ir-node)]))


;; ===== LUAU AST TO STRING =====

;; String conversion function types organized by node type
(define node-stringifiers
  (hash
   ;; Basic literals and variables
   'luau-literal
   (lambda (lit)
     (let ([val (luau-literal-val lit)])
       (cond
         [(string? val) (format "\"~a\"" (string-replace val "\"" "\\\""))] ; Escape quotes
         [(number? val) (number->string val)]
         [(boolean? val) (if val "true" "false")]
         [(symbol? val) (if (eq? val 'null) "nil" (format "\"~a\"" val))] ; Handle 'null symbol specially
         [(eq? val 'null) "nil"] ; Handle null/nil
         [(null? val) "nil"] ; Handle empty list as nil
         [else (error 'luau-ast->string "Unsupported literal type: ~s" val)])))

   'luau-var
   (lambda (var)
     (luau-var-name var))

   ;; Control flow
   'luau-if
   (lambda (if-node)
     (let* ((test-str (luau-ast->string (luau-if-test if-node)))
            ; Remove outer parentheses if they exist
            (test-str-no-parens 
             (if (and (> (string-length test-str) 1)
                      (char=? (string-ref test-str 0) #\()
                      (char=? (string-ref test-str (sub1 (string-length test-str))) #\))
                 (substring test-str 1 (sub1 (string-length test-str)))
                 test-str))
            (then-str (luau-ast->string (luau-if-then if-node)))
            (else-str (luau-ast->string (luau-if-else if-node))))
       (format "\tif ~a then\n\t\t~a\n\telse\n\t\t~a\n\tend"
               test-str-no-parens
               (string-replace then-str "\n" "\n\t\t")
               (string-replace else-str "\n" "\n\t\t"))))

   ;; Blocks and statements
   'luau-block
   (lambda (block)
     (string-join (map luau-ast->string (luau-block-stmts block)) "\n"))

   ;; Functions
   'luau-func
   (lambda (func)
     (format "function(~a)\n~a\nend"
             (string-join (map luau-ast->string (luau-func-params func)) ", ")
             (indent-string (luau-ast->string (luau-func-body func)))))

   'luau-function-def
   (lambda (func-def)
     (format "local function ~a(~a)\n~a\nend"
             (luau-function-def-name func-def)
             (string-join (map luau-ast->string (luau-function-def-params func-def)) ", ")
             (indent-string (string-join (map luau-ast->string (luau-function-def-body func-def)) "\n"))))

   ;; Function calls
   'luau-call
   (lambda (call)
     (format "~a(~a)"
             (luau-ast->string (luau-call-func call))
             (string-join (map luau-ast->string (luau-call-args call)) ", ")))

   'luau-method-call
   (lambda (call)
     (format "~a:~a(~a)"
             (luau-ast->string (luau-method-call-obj call))
             (luau-method-call-method call)
             (string-join (map luau-ast->string (luau-method-call-args call)) ", ")))

   ;; For loops
   'luau-for-numeric
   (lambda (loop)
     (let* ([var-str (luau-for-numeric-var loop)]
            [start-str (luau-ast->string (luau-for-numeric-start loop))]
            [end-str (luau-ast->string (luau-for-numeric-end loop))]
            [step-str (if (luau-for-numeric-step loop)
                         (format ", ~a" (luau-ast->string (luau-for-numeric-step loop)))
                         "")]
            [body-str (luau-ast->string (luau-for-numeric-body loop))])
       (format "for ~a = ~a, ~a~a do\n~a\nend"
               var-str
               start-str
               end-str
               step-str
               (indent-string body-str))))

   ;; Assignments
   'luau-assign-local
   (lambda (assign)
     (format "local ~a = ~a"
             (luau-assign-local-var assign)
             (luau-ast->string (luau-assign-local-val assign))))

   'luau-typed-assign-local
   (lambda (assign)
     (format "local ~a: ~a = ~a" 
             (luau-typed-assign-local-name assign)
             (luau-typed-assign-local-type assign)
             (luau-ast->string (luau-typed-assign-local-value assign))))

   'luau-assign
   (lambda (assign)
     (format "~a = ~a"
             (luau-ast->string (luau-assign-target assign))
             (luau-ast->string (luau-assign-val assign))))

   ;; Operators
   'luau-binop
   (lambda (binop)
     (format "(~a ~a ~a)" ; Parenthesize binary ops for safety
             (luau-ast->string (luau-binop-left binop))
             (luau-binop-op binop)
             (luau-ast->string (luau-binop-right binop))))

   ;; Tables
   'luau-table-literal
   (lambda (tbl)
     (if (null? (luau-table-literal-items tbl))
         "{}"
         (format "{%s}"
                (string-join (map luau-ast->string (luau-table-literal-items tbl)) ", "))))

   'luau-table-kv-literal
   (lambda (tbl)
     (if (null? (luau-table-kv-literal-pairs tbl))
         "{}"
         (format "{%s}"
                (string-join 
                 (map (lambda (pair)
                        (format "%s = %s"
                                (luau-ast->string (luau-table-pair-key pair))
                                (luau-ast->string (luau-table-pair-value pair))))
                      (luau-table-kv-literal-pairs tbl))
                 ", "))))

   'luau-table-pair
   (lambda (pair)
     (format "[~a] = ~a"
             (luau-ast->string (luau-table-pair-key pair))
             (luau-ast->string (luau-table-pair-value pair))))

   ;; Other statement types
   'luau-return
   (lambda (ret)
     (format "return ~a" (luau-ast->string (luau-return-val ret))))

   'luau-field-access
   (lambda (field-access)
     (let ([obj-str (luau-ast->string (luau-field-access-obj field-access))]
           [field (luau-field-access-field field-access)])
       (if (luau-ast? field)
           ;; Field is a Luau AST node
           (format "~a[~a]" obj-str (luau-ast->string field))
           ;; Field is a string
           (format "~a.~a" obj-str field))))

   ;; Top level module
   'luau-module
   (lambda (mod)
     (string-join (map luau-ast->string (luau-module-body mod)) "\n"))
   
   ;; Quasiquote nodes (needed for pattern matching)
   'luau-quasiquote
   (lambda (qq)
     (format "`~a" (luau-ast->string (luau-quasiquote-pattern qq))))
     
   'luau-unquote
   (lambda (uq)
     (format ",~a" (luau-ast->string (luau-unquote-pattern uq))))
   ))

;; Main conversion function: Luau AST -> String
(define (luau-ast->string node)
  (let* ([type (luau-node-type node)]
         [stringifier (hash-ref node-stringifiers type #f)])
    ;; For debugging
    (printf "Node type: ~s\n" type)
    (if stringifier
        (stringifier node)
        (error 'luau-ast->string "No stringifier for Luau node type: ~s ~s" type node))))

;; Helper for indentation
(define (indent-string str [level 1])
  (let ([indent (make-string (* level 2) #\space)]) ; Use 2 spaces for indent
    (string-join (map (lambda (line) (string-append indent line))
                      (string-split str "\n"))
                 "\n")))

;; Get the type symbol of a Luau AST node
(define (luau-node-type node)
  (cond
    [(luau-literal? node) 'luau-literal]
    [(luau-var? node) 'luau-var]
    [(luau-binop? node) 'luau-binop]
    [(luau-if? node) 'luau-if]
    [(luau-block? node) 'luau-block]
    [(luau-func? node) 'luau-func]
    [(luau-function-def? node) 'luau-function-def]
    [(luau-call? node) 'luau-call]
    [(luau-method-call? node) 'luau-method-call]
    [(luau-assign-local? node) 'luau-assign-local]
    [(luau-typed-assign-local? node) 'luau-typed-assign-local]
    [(luau-assign? node) 'luau-assign]
    [(luau-table-literal? node) 'luau-table-literal]
    [(luau-table-kv-literal? node) 'luau-table-kv-literal]
    [(luau-table-pair? node) 'luau-table-pair]
    [(luau-return? node) 'luau-return]
    [(luau-field-access? node) 'luau-field-access]
    [(luau-module? node) 'luau-module]
    [(luau-for-numeric? node) 'luau-for-numeric]
    [(luau-quasiquote? node) 'luau-quasiquote]
    [(luau-unquote? node) 'luau-unquote]
    [else (error 'luau-node-type "Unknown Luau AST node type: ~s" node)]))

;; ===== OLD HELPERS (Remove or integrate if needed) =====

;; ;; Helper for converting operator applications
;; (define (convert-operator-application func args)
;;   ...)

;; ;; Helper for converting FFI service calls
;; (define (convert-ffi-service-call func args)
;;   ...)

;; ;; Helper for converting table manipulation functions
;; (define (convert-table-operation func args)
;;   ...)

;; ;; Helper function to convert IR table literals to Luau table literals
;; (define (ir-table->luau-table items)
;;   ...)

;; ;; Convert an IR module to a Luau module
;; (define (ir->luau-ast ir-mod)
;;  ...) 

;; Helper function to generate let/letrec binding code
(define (generate-let-binding bindings body)
  ;; Convert let to a block with local declarations
  (let ([local-defs (map (lambda (b) 
                           (luau-assign-local 
                            (symbol->string (first b)) 
                            (ir->luau (second b))))
                         bindings)]
        [body-luau (ir->luau body)])
    ;; Put it all in a block with the body as the last expression
    (luau-block 
     (append local-defs 
             (if (luau-block? body-luau)
                 ;; If body is already a block, extract its statements
                 (luau-block-stmts body-luau)
                 ;; Otherwise add it as a single statement
                 (list body-luau))))))

;; Helper to determine if something is a Luau AST node
(define (luau-ast? obj)
  (and (struct? obj)
       (or (luau-literal? obj)
           (luau-var? obj)
           (luau-binop? obj)
           (luau-if? obj)
           (luau-block? obj)
           (luau-func? obj)
           (luau-function-def? obj)
           (luau-call? obj)
           (luau-method-call? obj)
           (luau-assign-local? obj)
           (luau-typed-assign-local? obj)
           (luau-assign? obj)
           (luau-table-literal? obj)
           (luau-table-kv-literal? obj)
           (luau-table-pair? obj)
           (luau-return? obj)
           (luau-field-access? obj)
           (luau-module? obj)
           (luau-quasiquote? obj)
           (luau-unquote? obj)
           (luau-for-numeric? obj)))) 