#lang racket/base

;; Rojo integration for Apollo compiler
;; Handles compiling entire Rojo projects with proper dependencies

(require racket/file
         racket/list
         racket/string
         racket/system
         json
         racket/match
         racket/path
         "../compiler/ir-types.rkt"
         "../compiler/ctfe.rkt"
         "../compiler/ir.rkt"
         "../compiler/parser.rkt"
         "../compiler/codegen.rkt")

(provide 
 compile-rojo-project
 compile-directory
 get-project-structure
 generate-roblox-module
 generate-declaration-file)

;; Main function to compile a Rojo project
(define (compile-rojo-project source-dir output-dir)
  (displayln (format "Compiling Rojo project from ~a to ~a" source-dir output-dir))
  
  ;; Ensure directories exist
  (make-directory* output-dir)
  
  ;; Parse project file if it exists
  (define project-file (build-path source-dir "default.project.json"))
  (define project-structure
    (if (file-exists? project-file)
        (get-project-structure project-file)
        #f))
  
  ;; Copy project file to output
  (when (file-exists? project-file)
    (copy-file project-file (build-path output-dir "default.project.json") #t))
  
  ;; Process the directory
  (compile-directory source-dir output-dir)
  
  ;; Return success message
  (format "Project compiled successfully to ~a" output-dir))

;; Process a directory recursively
(define (compile-directory source-dir output-dir)
  (define entries (directory-list source-dir))
  
  (for ([entry entries])
    (define source-path (build-path source-dir entry))
    (define output-path (build-path output-dir entry))
    
    (cond
      ;; Skip hidden files and directories
      [(regexp-match? #rx"^\\." (path->string entry))
       (void)]
      
      ;; Handle directories recursively
      [(directory-exists? source-path)
       (make-directory* output-path)
       (compile-directory source-path output-path)]
      
      ;; Handle Racket source files
      [(regexp-match? #rx"\\.rkt$" (path->string entry))
       (define output-luau-path 
         (path-replace-extension output-path ".luau"))
       (define output-decl-path
         (path-replace-extension output-path ".d.luau"))
       (compile-racket-file source-path output-luau-path output-decl-path)]
      
      ;; Copy other files as-is
      [else
       (copy-file source-path output-path #t)])))

;; Compile a single Racket file to Luau
(define (compile-racket-file input-file output-file decl-file)
  (displayln (format "Compiling ~a to ~a and ~a" input-file output-file decl-file))
  
  (with-handlers ([exn:fail? (lambda (e)
                               (displayln (format "Error compiling ~a: ~a" 
                                                  input-file 
                                                  (exn-message e))))])
    ;; Read the input Racket code
    (define racket-code (file->string input-file))
    
    ;; Check if it contains module dependencies
    (define dependencies (extract-dependencies racket-code))
    
    ;; Use the compiler pipeline
    (define racket-ast (parse-racket-string racket-code))
    (define ir (racket-to-ir racket-ast))
    (define luau-ast (ir->luau ir))
    
    ;; Generate Luau code with proper Roblox module structure
    (define luau-code (generate-roblox-module luau-ast dependencies))
    
    ;; Generate declaration file
    (define decl-code (generate-declaration-file racket-ast dependencies input-file))
    
    ;; Write the output files
    (with-output-to-file output-file
      #:exists 'replace
      (lambda () (display luau-code)))
    (with-output-to-file decl-file
      #:exists 'replace
      (lambda () (display decl-code)))))

;; Extract module dependencies from a Racket file
(define (extract-dependencies racket-code)
  ;; Simple regex-based approach to find require statements
  ;; A more robust implementation would parse the code properly
  (define requires '())
  (define require-pattern #rx"\\(require[[:space:]]+\"([^\"]+)\"\\)")
  
  (let loop ([start 0])
    (define match (regexp-match-positions require-pattern racket-code start))
    (if match
        (let* ([full-match (car match)]
               [path-match (cadr match)]
               [path-str (substring racket-code 
                                    (car path-match) 
                                    (cdr path-match))])
          (set! requires (cons path-str requires))
          (loop (cdr full-match)))
        requires)))

;; Generate Luau code with proper Roblox module structure
(define (generate-roblox-module luau-ast dependencies)
  (define basic-luau (luau-ast->string luau-ast))
  
  ;; Add Roblox-specific header and module structure
  (string-append 
   "-- Generated by Apollo Racket-to-Luau Compiler\n"
   "-- https://github.com/yourusername/apollo\n\n"
   
   ;; Add dependencies as require statements
   (string-join
    (map (lambda (dep)
           (format "local %s = require(script.Parent.%s)"
                   (path->string (file-name-from-path (string->path dep)))
                   (path->string (file-name-from-path (string->path dep)))))
         dependencies)
    "\n")
   
   (if (null? dependencies) "" "\n\n")
   
   ;; Main module code
   basic-luau
   
   ;; Return statement for ModuleScript compatibility
   "\n\nreturn {\n"
   "    -- Export public functions and values\n"
   "    -- This will be auto-populated in future versions\n"
   "}\n"))

;; Generate declaration file for Luau
(define (generate-declaration-file racket-ast dependencies input-file)
  (string-append
   "-- Type declarations for " (path->string (file-name-from-path input-file)) "\n"
   "-- Generated by Apollo Racket-to-Luau Compiler\n\n"
   
   ;; Import dependencies
   (string-join
    (map (lambda (dep)
           (format "local %s: typeof(require(script.Parent.%s))"
                   (path->string (file-name-from-path (string->path dep)))
                   (path->string (file-name-from-path (string->path dep)))))
         dependencies)
    "\n")
   
   (if (null? dependencies) "" "\n\n")
   
   ;; Generate type declarations from Racket AST
   (generate-type-declarations racket-ast)
   
   ;; Export declarations
   "\n\nexport type Module = {\n"
   "    -- Export declarations will be populated here\n"
   "}\n\n"
   "return Module"))

;; Generate type declarations from Racket AST
(define (generate-type-declarations ast)
  (cond
    [(and (list? ast) (>= (length ast) 3) (equal? (car ast) 'define-values))
     (let ([ids (cadr ast)]
           [expr (caddr ast)])
       (string-join
        (map (lambda (id)
               (format "export type ~a = any" 
                       (symbol->string id)))
             ids)
        "\n"))]
    [(and (list? ast) (>= (length ast) 3) (equal? (car ast) 'define-syntaxes))
     (let ([ids (cadr ast)])
       (string-join
        (map (lambda (id)
               (format "-- @syntax ~a" (symbol->string id)))
             ids)
        "\n"))]
    [else ""]))

;; Convert Racket types to Luau types
(define (racket-type->luau-type type)
  (match type
    ['Number "number"]
    ['String "string"]
    ['Boolean "boolean"]
    ['Void "nil"]
    ['Any "any"]
    [(list '-> args ... ret)
     (format "(%s) -> %s"
             (string-join (map racket-type->luau-type args) ", ")
             (racket-type->luau-type ret))]
    [(list 'Listof elem-type)
     (format "{ %s }" (racket-type->luau-type elem-type))]
    [(list 'Vectorof elem-type)
     (format "{ %s }" (racket-type->luau-type elem-type))]
    [(list 'HashTable key-type val-type)
     (format "{ [%s]: %s }" 
             (racket-type->luau-type key-type)
             (racket-type->luau-type val-type))]
    [(list 'Option elem-type)
     (format "%s?" (racket-type->luau-type elem-type))]
    [_ "any"]))

;; Parse Rojo project structure
(define (get-project-structure project-file)
  (define project-json
    (with-input-from-file project-file read-json))
  
  ;; Extract project name and tree structure
  (define project-name (hash-ref project-json 'name "RojoProject"))
  (define tree (hash-ref project-json 'tree #hash()))
  
  ;; Return project info
  (hash 'name project-name
        'tree tree))

;; Utility to extract just the file name from a path, removing extension
(define (file-name-from-path path-obj)
  (define name-str (path->string (last (explode-path path-obj))))
  (define parts (string-split name-str "."))
  (if (> (length parts) 1)
      (string->path (car parts))
      (string->path name-str))) 